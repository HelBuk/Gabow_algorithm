# -*- coding: utf-8 -*-
"""gabow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JK_BQpVJMpsflhou4Tv-8BaiedmrNtZ3
"""

import networkx as nx
import matplotlib.pyplot as plt

G = nx.DiGraph()
G.graph['author'] = "Gabow"
#G_1 = nx.DiGraph()
#G_1.graph['author'] = "Sethi"
#G_2 = nx.DiGraph()
#G_2.graph['author'] = "Coffman"

elist_g = [('16', '14'), ('16', '13'), ('15', '12'), ('14', '12'), ('13', '12'), ('12', '11'), ('10', '5'), ('12', '9'), ('11', '8'), ('12', '7'), ('12', '6'), ('9', '5'), ('9', '4'), ('8', '5'), ('8', '4'), ('7', '5'), ('7', '4'), ('6', '4'), ('5', '3'), ('4', '2'), ('4', '1')]
elist_s = [('15', '14'), ('16', '14'), ('17', '14'), ('17', '7'), ('14', '9'), ('14', '13'), ('7', '5'), ('13', '11'), ('13', '12'), ('11', '8'), ('12', '8'), ('12', '10'), ('9', '5'), ('9', '6'), ('10', '5'), ('10', '4'), ('10', '6'), ('8', '1'), ('8', '6'), ('8', '4'), ('5', '1'), ('5', '3'), ('6', '2'), ('6', '3'), ('4', '3')]
elist_c = [('19', '6'),('19', '17'),('18', '17'),('17', '16'),('17', '15'),('16', '14'),('16', '13'),('15', '14'),('14', '12'),('14', '11'),('13', '10'),('12', '8'),('12', '9'),('11', '8'),('11', '9'),('10', '8'),('10', '9'), ('9', '7'),('8', '7'),('6', '4'),('7', '5'),('7', '3'),('4', '1'),('3', '1'),('5', '1'),('5', '2')]
G.add_edges_from(elist_g)
#G.remove_nodes_from(e)

G.number_of_nodes()
#G.nodes
G.number_of_edges()

for node in G.nodes:
  G.nodes[node]['time'] = 1.0
  G.nodes[node]['Level'] = 0

G.nodes.data()

nx.draw(G)

"""Разделение вершин dag G на уровни:"""

G.adj  # or G.successors(node_s)

"""Алгоритм поиска в ширину

   // при условии, что мы имеем дело со смежным списком
  // например, таким: adj = {A:[B,C,D], B:[E,F], ... }
function bfs(adj, s, t) {
	// adj - смежный список
	// s - начальная вершина
	// t - пункт назначения

	// инициализируем очередь
	let queue = []
	// добавляем s в очередь
	queue.push(s)
	// помечаем s как посещенную вершину во избежание повторного добавления в очередь
	s.visited = true
	while(queue.length > 0) {
		// удаляем первый (верхний) элемент из очереди
		let v = queue.shift()
		// abj[v] - соседи v
		for(let neighbor of adj[v]) {
			// если сосед не посещался
			if(!neighbor.visited) {
				// добавляем его в очередь
				queue.push(neighbor)
				// помечаем вершину как посещенную
				neighbor.visited = true
				// если сосед является пунктом назначения, мы победили
				if(neighbor === t) return true
			}
		} 
	}
	// если t не обнаружено, значит пункта назначения достичь невозможно
	return false
}
"""

t_nodes = [] #список вершин без последователей
h_term = [] #список вершин без предшественников
leveled = []

def func(start_node):
  queque = []
  queque.append(start_node)
  while len(queque) > 0:
    v = queque.pop(0)
    for neighbour in list(G.predecessors(v)):
      if G.nodes[neighbour]['Level'] <  G.nodes[v]['Level'] + 1:
        queque.append(neighbour)
        G.nodes[neighbour]['Level'] = G.nodes[v]['Level'] + 1
  return (f"Прошел весь граф, начиная с вершины: {start_node}")

for node in G.nodes:
  if len(list(G.successors(node))) == 0:
    G.nodes[node]['Level'] = 1
    t_nodes.append(node)
  else: 
    G.nodes[node]['Level'] = 0 #всем остальным вершинам задаем уровень = 0
  if len(list(G.predecessors(node))) == 0:
    h_term.append(node)

  
for st_node in t_nodes:
  func(st_node)

G.nodes.data()

"""Алгоритм Gabow

Initialization
"""

Levels = [] #список уровней
L = 0 #максимальный уровень графа
for node in G.nodes:
  if not G.nodes[node]['Level'] in Levels:
    Levels.append(G.nodes[node]['Level'])
  if G.nodes[node]['Level'] > L:
    L = G.nodes[node]['Level']

SUB = {t: 0 for t in Levels} #запасная вершина
SUB.update({0: 0})
T = {t: 0 for t in Levels} #вершина - item, на которую совершается прыжок с уровня - key
RLIST = {t: [] for t in Levels} #Список вершин - item, на которые можно спрыгнуть с уровня f - key
#LSET_list = [] #Список не-open уровней c единственным open уровнем в конце списка
LSET = {t: [t] for t in Levels}
R = {0: 0 } # item - наивысший уровень, с которого можно спрыгнуть на вершину - key 

Levels_dict = {} #item - список вершин: nodes_on_level, которые расположены на уровне - key
nodes_on_level = []

Levels.sort
for t in Levels:
  for node in G.nodes:
    if G.nodes[node]['Level'] == t:
      nodes_on_level.append(node)
      Levels_dict.update({G.nodes[node]['Level']: nodes_on_level})
  nodes_on_level = []



"""Функции, необходимые для работы алгоритма"""

def free_check(node): #функция проверяет, является ли вершина free
      if node in G.nodes:
        if node in T.values() and SUB[G.nodes[node]['Level']] == 0:
          return False
        elif SUB[G.nodes[node]['Level']] != 0 and node in T.values():
          for (f, k) in T.items():
            if node == k and f > R[SUB[G.nodes[node]['Level']]]:
              return False
        return True


def FIND(g):
  for key in LSET:
    if g in LSET[key]:
      return key


def UNION(f, g):
  LSET[g].extend(LSET[f])
  LSET[f] = []
  LSET[g].sort

def l_level_check(t): #функция проверяет, является ли уровень "l-level"
  cnt = 0
  for key in T:
    for node in Levels_dict[t]:
      if node == T[key]:
        cnt +=1
  node_amount = len(Levels_dict[t])
  if (node_amount - cnt)%2: #нечетное число вершин -> l-level
    return True
  else: 
    return False

Levels_dict

"""Pass 1"""

for t in range(L, 0, -1): #c L до 1
  for node in Levels_dict[t]:
    if node in h_term:
      l = L+1
    else:
      l_min = L
      for node_p in list(G.predecessors(node)):
        if l_min >= G.nodes[node_p]['Level']:
            l_min = G.nodes[node_p]['Level']

      for node_l in Levels_dict[l_min]:
        if node_l in list(G.predecessors(node)):
          if not node_l in T.values():
            l = l_min  
            break
          else: 
            for key in T:
              if node_l == T[key]:
                if l >= key:
                  l = key


    r = min(L+1, l)
    l = L

    if r <= L and T[r] == 0:
      for node_r in Levels_dict[r]:
        if not node_r in list(G.predecessors(node)):
          if free_check(node_r):
            R[node] = r
            break
        R[node] = FIND(r-1)
    else:
      R[node] = FIND(r-1)


    RLIST[R[node]].append(node)
  for f in RLIST:
    while f > t and RLIST[f] != []:
      T[f] = RLIST[f].pop(0)
      g = FIND(f-1)
      UNION(f, g)
      RLIST[g].extend(RLIST[f])
      RLIST[f] = []
  z = RLIST[t][len(RLIST[t]) - 1]
  RLIST[t] = []
  if R[z] > t:
    SUB[t] = z
  
  if not l_level_check(t):
    T[t] = -1
    if not t-1 == 0:
      UNION(t, t-1)

"""Значения уровней f, с которых необходим прыжок, и значения вершины T[f], в которую этот прыжок совершается, после прохождения Pass 1:"""

for f in Levels_dict:
  print(f'f = {f}, T[f] = {T[f]}, SUB[f]: {SUB[f]}')

"""Значения вершин y и наибольший уровень R(y), с которого можно совершиться прыжок на y, после прохождения Pass 1:"""

for node in G.nodes:
  print(f'y = {node}, R(y) = {R[node]}')

"""Pass 2"""

TO = T
FROM = {f: 0 for f in Levels}
for f in range(1, L+1): # from 1 to L
  if int(TO[f]) >= 0:
    for node in Levels_dict[f]:
      if free_check(node):
        if int(TO[f]) > 0:
          if not node in G.predecessors(TO[f]):
            FROM[f] = node
            break
        FROM[f] = node
    for g in range(1, L+1):
      if FROM[f] == TO[g]:
        TO[g] = SUB[f]

"""Значения вершин FROM[t], с которых необходим прыжок, и исправленные (если это было необходимо) значения вершины TO[f], в которую этот прыжок совершается, после прохождения Pass 2:"""

for t in Levels:
  print(f'FROM(t) = {FROM[t]}, TO(t) = {TO[t]}, type(FROM(t)) = {type(FROM[t])}')

"""Составление расписания:"""

#Processors_dict = {1: [], 2: []}
#for t in range(len(Levels.keys()), 0, -1):
#  if FROM(t) != 0:
#    Processors_dict[1].append(FROM(t))